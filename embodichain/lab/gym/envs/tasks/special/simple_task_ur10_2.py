# ----------------------------------------------------------------------------
# Copyright (c) 2021-2025 DexForce Technology Co., Ltd.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------

import torch

from embodichain.lab.gym.envs import EmbodiedEnv, EmbodiedEnvCfg
from embodichain.lab.gym.utils.registration import register_env
from embodichain.utils import logger

__all__ = ["SimpleTaskEnv_2"]


@register_env("simple_task_2", max_episode_steps=600)
class SimpleTaskEnv_2(EmbodiedEnv):
    """A demo environment with spiral trajectory

    Args:
        EmbodiedEnv (_type_): _description_
    """

    def __init__(self, cfg: EmbodiedEnvCfg = None, **kwargs):
        super().__init__(cfg, **kwargs)

    def create_demo_action_list(self, *args, **kwargs):
        """
        Create a demonstration action list for the current task.

        This demo creates a spiral upward trajectory for the robot joints.

        Returns:
            list: A list of demo actions generated by the task.
        """
        action_list = []
        num_steps = 100

        # Get initial pose
        init_pose = self.robot.get_qpos()  # shape: (num_envs, num_joints)

        # Create a spiral upward trajectory
        for i in range(num_steps):
            # Calculate phase for spiral motion
            t = i / num_steps  # 0 to 1
            phase = torch.full(
                (init_pose.shape[0],), t * 4 * 3.14159, device=self.device
            )  # repeat for num_envs

            # Create spiral offsets
            # Radius decreases as it goes up
            radius = 0.4 * (1 - t * 0.5)  # Start at 0.4, end at 0.2

            offset = torch.zeros_like(
                init_pose, dtype=torch.float32, device=self.device
            )
            offset[:, 0] = torch.cos(phase) * radius  # X-axis circular motion
            offset[:, 1] = torch.sin(phase) * radius  # Y-axis circular motion
            offset[:, 2] = t * 0.5  # Z-axis upward motion (0 to 0.5 rad)

            # Add wrist rotation
            if init_pose.shape[1] > 3:
                offset[:, 3] = phase * 0.3  # Continuous rotation
            if init_pose.shape[1] > 4:
                offset[:, 4] = (
                    torch.sin(phase * 3) * 0.15
                )  # Triple frequency oscillation
            if init_pose.shape[1] > 5:
                offset[:, 5] = t * 0.2  # Gradual opening

            # Add small random variation
            noise = (torch.rand_like(init_pose, device=self.device) - 0.5) * 0.01

            # Compute action
            action = init_pose + offset + noise

            # Clamp to joint limits if available
            if hasattr(self.robot.body_data, "qpos_limits"):
                qpos_limits = self.robot.body_data.qpos_limits[0]  # (num_joints, 2)
                action = torch.clamp(action, qpos_limits[:, 0], qpos_limits[:, 1])

            action_list.append(action)

        logger.log_info(
            f"Generated {len(action_list)} demo actions with spiral trajectory"
        )
        return action_list
